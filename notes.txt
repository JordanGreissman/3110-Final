- How to store info which will probably have to be looked up by multiple types
  of keys?
  e.g. location of units: a unit should store its position (which makes it easy
  to look up where a given unit is), but should a tile also store a list on
  units that are on it? If yes, have to update multiple data structures whenever
  a unit moves, if no, looking up whether a list of units on a given tile
  becomes an expensive operation.

- clarify resources: What is a "production type" string in the documentation for Hub.create?

questions for OH:
  - how to implement java-like interfaces with ocaml modules

    In student.mli:
        type t
        val print_stats t -> unit
    In teacher.mli:
        type t
        val print_stats t -> unit
    In stats.ml:
        type statable =
          | Student of Student.t
          | Teacher of Teacher.t
        print_stats = function
          | Student t -> Student.print_stats t
          | Teacher t -> Teacher.print_stats t

  - is passing around ids instead of data structures actually more efficient in ocaml?
     the pass-by-value/pass-by-reference optimization is already very well
     handled by the ocaml compiler. So passing around Tile.t will be as
     efficient as it is in java (i.e. the ocaml compiler knows to actually store
     this struct somewhere and just pass a pointer to it)
  - why "a module for every type"? (use tile.mli as an example)
     Sometimes it's necessary to wrap some simple stuff in a module in order to
     pass it into a functor. In general, modules sometimes seem like the right
     choice but make code more complicated than it needs to be.

Wed meeting TODO:
    - clarify arguments to `create' functions, convert these into named arguments
    - remove_entity in hub.mli: we said this wasn't possible, right?
    - what does Hub.remove do?

Hubs produce resources
Clusters consume resources in order to sustain the population of the cluster
The production output of each cluster has to satisfy the needs of that cluster
(it is not the case that the total production across all clusters has to satisfy
the needs of all clusters combined).
If the resource needs of the cluster aren't met, production of hubs and clusters
takes twice as long

Workers can be added to a hub after the hub has been constructed in order to
increase its production rate.
Multiple workers can be tasked with the construction of a hub, however when the
hub is completed, only one worker is "put inside" the hub (and contributes to
its production), the others are simply consumed.

TODO: how to extract requirements once they've been fulfilled?
TODO: fix text in menu being cut off (it should wrap around)
TODO: how to implement town hall?
  => Town hall is special because it's the only hub to produce both
     resources (one of everything?) and units.
TODO: implement and debug all commands
TODO: tutorial
TODO: add clusters to initial map generation
TODO: implement describable interface
TODO: need to be careful of range issues with `change_*' functions
  => make sure that value can't overflow

I think clusters can be implemented differently. Instead of having the cluster
store any data about itself, have each tile store whether it is part of a tile.
This way, operations which modify clusters don't have to awkwardly return both
the updated cluster and the updated map, and the map becomes the sole authority
on the map state, as its name implies. One potential problem with this solution
is whether it then becomes an expensive operation to compute a list of all the
tiles in a certain cluster, but I think this can be done efficiently. Simply
start with the town hall of the cluster, and for each tile, add it to the list,
and then recursively look at its 6 neighbors, since the cluster must be
contiguous. This avoids a brute-force search for cluster membership.
