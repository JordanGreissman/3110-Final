- How to store info which will probably have to be looked up by multiple types
  of keys?
  e.g. location of units: a unit should store its position (which makes it easy
  to look up where a given unit is), but should a tile also store a list on
  units that are on it? If yes, have to update multiple data structures whenever
  a unit moves, if no, looking up whether a list of units on a given tile
  becomes an expensive operation.

- clarify resources: What is a "production type" string in the documentation for Hub.create?

questions for OH:
  - how to implement java-like interfaces with ocaml modules

    In student.mli:
        type t
        val print_stats t -> unit
    In teacher.mli:
        type t
        val print_stats t -> unit
    In stats.ml:
        type statable =
          | Student of Student.t
          | Teacher of Teacher.t
        print_stats = function
          | Student t -> Student.print_stats t
          | Teacher t -> Teacher.print_stats t

  - is passing around ids instead of data structures actually more efficient in ocaml?
     the pass-by-value/pass-by-reference optimization is already very well
     handled by the ocaml compiler. So passing around Tile.t will be as
     efficient as it is in java (i.e. the ocaml compiler knows to actually store
     this struct somewhere and just pass a pointer to it)
  - why "a module for every type"? (use tile.mli as an example)
     Sometimes it's necessary to wrap some simple stuff in a module in order to
     pass it into a functor. In general, modules sometimes seem like the right
     choice but make code more complicated than it needs to be.

Wed meeting TODO:
    - clarify arguments to `create' functions, convert these into named arguments
    - remove_entity in hub.mli: we said this wasn't possible, right?
    - what does Hub.remove do?

Hubs produce resources
Clusters consume resources in order to sustain the population of the cluster
The production output of each cluster has to satisfy the needs of that cluster
(it is not the case that the total production across all clusters has to satisfy
the needs of all clusters combined).
If the resource needs of the cluster aren't met, production of hubs and clusters
takes twice as long

Workers can be added to a hub after the hub has been constructed in order to
increase its production rate.
Multiple workers can be tasked with the construction of a hub, however when the
hub is completed, only one worker is "put inside" the hub (and contributes to
its production), the others are simply consumed.

TODO: ascii art
    - role interfaces for hubs and entities
    - json parser (parsing the roles and creating that data structure)
    - Art module (loading and parsing art)
    - Tile module
        - function to return the art info (char + color) for a given Coord.Screen.t
        - since the art for the hub/entity on the tile in question is stored in
        the Hub or Entity module, it has no sense of absolute positioning. So
        how to convert the Coord.Screen.t into a coordinate relative to the
        ascii art, so we can get the right character?
        - Need a "null" character for ascii art, and a default background
        character. This is because the ascii art has "layers". Entities and hubs
        can exist on the same tile at the same time, and additionally the
        terrain has ascii art. Entities are always drawn on top, then hubs, then
        the terrain. Most entities won't take up the entire tile, so the ascii
        art of whatever's "behind" the entity (a hub, if one exists, or the
        terrain) should be drawn in the cells where the entity has no art. This
        means that in the ascii art file for the entity, there has to be a way
        to explicitly state that the entity does not have any art on certain
        cells. Additionally, there should be a "default" character, which is
        drawn as the last resort if nothing else is being drawn on that cell
        (this won't happen on the map once the game is fleshed out more, but it
        will happen off the edges of the map, and in the meantime it will be
        good for debugging).

TODO: exception architecture?
  => When the player performs an illegal action or the like, how does this get
  propagated up to the interface so that they can see it? How do we separate
  errors that are routine and expected from those which are game-breaking?
    => create custom exception types for the game
  => functions which raise exceptions must be documented in their mli files
  => in the case that a function raises an exception, how do we know the latest
  state of the data structure that function was modifying? (e.g. if
  Hub.add_entity raises an exception, do we assume that the hub was unchanged?)
  Seems like a good assumption
TODO: how to implement town hall?
  => Town hall is special because it's the only hub to produce both
     resources (one of everything?) and units.
TODO: implement describable interface
TODO: need to be careful of range issues with `change_*' functions
  => make sure that value can't overflow
TODO: implement "clearing" mechanic
  - Forest tiles cannot be built on until they are "cleared"
  - Cleared forest tiles become flatland tiles
    => so it's possible to change the type of a tile, but I don't think
       this one case merits exposing a function because the type can be changed internally
  - Forests can only be cleared by a certain type of unit, and only once a
    certain research is acquired

- Map => Mapp
- [create] functions now take labeled arguments instead of positional ones
- improved documentation
- created Coord.{ml,mli}
