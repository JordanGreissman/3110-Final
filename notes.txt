- How to store info which will probably have to be looked up by multiple types
  of keys?
  e.g. location of units: a unit should store its position (which makes it easy
  to look up where a given unit is), but should a tile also store a list on
  units that are on it? If yes, have to update multiple data structures whenever
  a unit moves, if no, looking up whether a list of units on a given tile
  becomes an expensive operation.

- clarify resources: What is a "production type" string in the documentation for Hub.create?

questions for OH:
  - how to implement java-like interfaces with ocaml modules

    In student.mli:
        type t
        val print_stats t -> unit
    In teacher.mli:
        type t
        val print_stats t -> unit
    In stats.ml:
        type statable =
          | Student of Student.t
          | Teacher of Teacher.t
        print_stats = function
          | Student t -> Student.print_stats t
          | Teacher t -> Teacher.print_stats t

  - is passing around ids instead of data structures actually more efficient in ocaml?
     the pass-by-value/pass-by-reference optimization is already very well
     handled by the ocaml compiler. So passing around Tile.t will be as
     efficient as it is in java (i.e. the ocaml compiler knows to actually store
     this struct somewhere and just pass a pointer to it)
  - why "a module for every type"? (use tile.mli as an example)
     Sometimes it's necessary to wrap some simple stuff in a module in order to
     pass it into a functor. In general, modules sometimes seem like the right
     choice but make code more complicated than it needs to be.

Wed meeting TODO:
    - clarify arguments to `create' functions, convert these into named arguments
    - remove_entity in hub.mli: we said this wasn't possible, right?
    - what does Hub.remove do?

Hubs produce resources
Clusters consume resources in order to sustain the population of the cluster
The production output of each cluster has to satisfy the needs of that cluster
(it is not the case that the total production across all clusters has to satisfy
the needs of all clusters combined).
If the resource needs of the cluster aren't met, production of hubs and clusters
takes twice as long

Workers can be added to a hub after the hub has been constructed in order to
increase its production rate.
Multiple workers can be tasked with the construction of a hub, however when the
hub is completed, only one worker is "put inside" the hub (and contributes to
its production), the others are simply consumed.

TODO: ascii art
    - role interfaces for hubs and entities
    - json parser (parsing the roles and creating that data structure)
    - Art module (loading and parsing art)
    - Tile module
        - function to return the art info (char + color) for a given Coord.Screen.t
        - since the art for the hub/entity on the tile in question is stored in
          the Hub or Entity module, it has no sense of absolute positioning. So
          how to convert the Coord.Screen.t into a coordinate relative to the
          ascii art, so we can get the right character?
        - Need a "null" character for ascii art, and a default background
          character. This is because the ascii art has "layers". Entities and hubs
          can exist on the same tile at the same time, and additionally the
          terrain has ascii art. Entities are always drawn on top, then hubs, then
          the terrain. Most entities won't take up the entire tile, so the ascii
          art of whatever's "behind" the entity (a hub, if one exists, or the
          terrain) should be drawn in the cells where the entity has no art. This
          means that in the ascii art file for the entity, there has to be a way
          to explicitly state that the entity does not have any art on certain
          cells. Additionally, there should be a "default" character, which is
          drawn as the last resort if nothing else is being drawn on that cell
          (this won't happen on the map once the game is fleshed out more, but it
          will happen off the edges of the map, and in the meantime it will be
          good for debugging).
TODO: exception architecture?
  => When the player performs an illegal action or the like, how does this get
  propagated up to the interface so that they can see it? How do we separate
  errors that are routine and expected from those which are game-breaking?
    => create custom exception types for the game
  => functions which raise exceptions must be documented in their mli files
  => in the case that a function raises an exception, how do we know the latest
  state of the data structure that function was modifying? (e.g. if
  Hub.add_entity raises an exception, do we assume that the hub was unchanged?)
  Seems like a good assumption

NOTE that functions should be able to generate info messages to. That is, the
function completes successfully, but a message is added to the queue as a side-effect.

TODO: menus
  => when you click on a tile, the menu along the left side (which doesn't exist
  yet) should be populated with things you can do on that tile. There are two
  ways to implement this:
    - Have each action bound to a key
    - Have each action be a button (which is clicked with the mouse)
  You can do buttons in lambda-term with widgets, but idk if I want to get into
  all of this ocaml object-oriented nonsense. I could also roll my own buttons,
  but not sure how difficult this would be.
  => I also have to know what options are available for the selected tile. This
  will typically be a union of the options available for the hub that's on the
  tile and the options available for the entity that's on the tile (if they
  exist). Also, the tile itself may have menu items, like "Clear" for a forest.
  So Tile should have a function which returns a list of all the menu items
  available for a given tile and the "commands" they're bound to.
  => This implies that there needs to be a way to represent an "action" that the
  player wants to take (some kind of type?)
  => We also need to deal with long menus and sub-menus. Obviously the menu
  can't run off the bottom of the screen, all the options must be visible for
  all menus. Because of variable screen and terminal sizes, I think the simplest
  thing is to have a [m]ore key that will show whatever part of the menu got cut
  off, etc. This works because when I go to display a menu at runtime, I know
  how many items are in the menu, and the height of the context I'm drawing them
  on, so I can pre-compute how many "pages" of menu there will have to be.
  So it will probably look like:
+-------------------+
| [p] previous page |
|                   |
| [a] Action A      |
| [b] Action B      |
|     ...           |
| [z] Action Z      |
|                   |
| [n] next page     |
+-------------------+
  Some items (like the town hall) will have a shitton of actions
  available, so it makes sense to organize them into sub-menus. Then the action
  for certain menu items is something like "ShowSubMenu {menu record}" which
  will cause the submenu to be displayed.
  => There should be a tutorial, explaning how the game works and basic
  keybindings, which is always available as the last menu option. I think it
  should be bound to '?'.

Idea: maybe instead of making a union of the hub and entity and tile menus, we
simply make the initial menu:

+---------------+
| Action for:   |
|               |
|  [t] tile     |
|  [e] entity   |
|  [h] hub      |
|               |
+---------------+

This way we can plan in advance how the menus and sub-menus are going to be laid
out, and we're guaranteed that they'll fit (because they're not being combined
with other menus on the fly). It also means that the keybindings don't have to
be generated on the fly (if I choose to use keybindings), because we're not
combining menus so there's no change for a keybinding conflict between menus.

So make the menu options and the associated commands part of the json for each
entity type. These will be parsed into part of the each Hub.role_info and
Entity.role_info records. Then

TODO: procedural map generation
TODO: how to implement town hall?
  => Town hall is special because it's the only hub to produce both
     resources (one of everything?) and units.
TODO: implement describable interface
TODO: need to be careful of range issues with `change_*' functions
  => make sure that value can't overflow
TODO: implement "clearing" mechanic
  - Forest tiles cannot be built on until they are "cleared"
  - Cleared forest tiles become flatland tiles
    => so it's possible to change the type of a tile, but I don't think
       this one case merits exposing a function because the type can be changed internally
  - Forests can only be cleared by a certain type of unit, and only once a
    certain research is acquired

- Map => Mapp
- [create] functions now take labeled arguments instead of positional ones
- improved documentation
- created Coord.{ml,mli}
